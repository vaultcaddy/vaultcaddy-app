# 🌍 全球银行对账单通用识别方案

**设计日期**: 2026-01-10  
**目标**: 支持全球所有银行的对账单格式  
**核心理念**: 智能识别，而非硬编码规则

---

## 📋 挑战分析

### **为什么这很难？**

不同银行的对账单格式完全不同：

| 银行类型 | 列结构 | 示例 |
|---------|--------|------|
| **类型A** | 双列金额 | `日期 描述 支出 存入 余额` |
| **类型B** | 单列金额+正负号 | `日期 描述 金额 余额` |
| **类型C** | 只有余额变化 | `日期 描述 余额` |
| **类型D** | 完全自定义 | 各种奇怪格式 |

**具体差异**：
1. 列的顺序不同
2. 列名不同（中文/英文/其他语言）
3. 金额表示方式不同（双列 vs 单列+正负号）
4. 有些银行没有明确的支出/存入列

---

## ✅ 解决方案：智能识别

### **核心思路**

❌ **不要**：硬编码特定银行格式  
✅ **要**：教AI理解表格结构，自己判断

### **实施策略**

#### **步骤1：观察表头**
```
让AI首先识别：
- 有多少列？
- 每列叫什么名字？
- 哪些列可能是金额？
- 哪一列是余额？
```

#### **步骤2：理解常见格式**

**格式A（双列金额）**：
```
| 日期 | 描述 | 支出 | 存入 | 余额 |
| 2021-07-06 | CQW 000012 | 25,655.00 |  | 15,531.71 |
```
特征：
- 有两列金额
- 每行只有一列有数字
- 余额在最右边

**格式B（单列金额+正负号）**：
```
| 日期 | 描述 | 金额 | 余额 |
| 2021-07-06 | CQW 000012 | -25,655.00 | 15,531.71 |
```
特征：
- 只有一列金额
- 使用正负号区分收入/支出
- 负数 = 支出，正数 = 收入

**格式C（只有余额）**：
```
| 日期 | 描述 | 余额 |
| 2021-07-06 | CQW 000012 | 15,531.71 |
```
特征：
- 只显示余额
- 需要通过余额变化推算交易金额

#### **步骤3：智能判断**

```javascript
识别逻辑：
1. 看列数：
   - 5列以上 → 可能是双列金额
   - 3-4列 → 可能是单列金额
   - 2-3列 → 可能只有余额

2. 看数据特征：
   - 有些行某列为空 → 双列格式
   - 金额有正负号 → 单列格式
   - 所有行余额都有值 → 余额列

3. 看表头：
   - "借方"+"贷方" → 双列格式
   - "Debit"+"Credit" → 双列格式
   - 只有"Amount" → 单列格式
```

---

## 🔧 技术实现

### **改进的Prompt结构**

```javascript
1. 先观察表头和列结构
2. 识别格式类型（A/B/C）
3. 根据格式提取数据
4. 验证数据合理性
```

### **关键改进**

#### **1. 教AI观察表格**
```
步骤1：先观察表头和列结构
- 仔细查看交易记录表格的表头
- 识别有多少列，每列的名称是什么
- 常见的列名：日期、描述、支出、存入、余额
```

#### **2. 提供多种格式示例**
```
格式A（双列）：| 日期 | 描述 | 支出 | 存入 | 余额 |
格式B（单列）：| 日期 | 描述 | 金额 | 余额 |
格式C（余额）：| 日期 | 描述 | 余额 |
```

#### **3. 智能识别规则**
```
🔍 看列数
🔍 看数据特征（空值、正负号）
🔍 看表头关键词
🔍 看位置（余额通常在最右边）
```

#### **4. 验证逻辑**
```
✅ amount = debit 或 credit（不应该 = balance）
✅ 连续交易的余额应该连贯
✅ 前一笔余额 ± 本次金额 = 本次余额
✅ 如果不连贯 → 提取可能错误
```

---

## 📊 适配不同银行

### **全球主要银行格式**

| 地区 | 银行 | 格式类型 | 特点 |
|------|------|----------|------|
| 🇭🇰 香港 | HSBC, ICBC, 恒生 | A（双列） | 支出/存入分开 |
| 🇺🇸 美国 | Chase, BoA, Wells Fargo | B（单列） | 用正负号 |
| 🇬🇧 英国 | Barclays, HSBC UK | A（双列） | Debit/Credit |
| 🇯🇵 日本 | MUFG, SMBC | A（双列） | 出金/入金 |
| 🇨🇳 中国 | 工行, 建行, 招行 | A（双列） | 借方/贷方 |
| 🇸🇬 新加坡 | DBS, OCBC | B（单列） | 正负号 |

### **适配策略**

✅ **不针对特定银行**：
- 不写"如果是ICBC就这样处理"
- 不写"如果是HSBC就那样处理"

✅ **针对格式特征**：
- "如果有两列金额，就按双列处理"
- "如果金额有正负号，就按单列处理"
- "如果只有余额，就根据变化推算"

---

## 🧪 测试计划

### **测试不同银行**

1. **香港银行**（双列格式）
   - ICBC ✅
   - HSBC
   - 恒生银行
   
2. **美国银行**（单列+正负号）
   - Chase
   - Bank of America
   
3. **欧洲银行**（双列格式）
   - Barclays
   - Deutsche Bank
   
4. **亚洲其他银行**
   - DBS（新加坡）
   - MUFG（日本）

### **验证标准**

✅ 正确识别列结构  
✅ 正确提取交易金额  
✅ 正确识别收入/支出  
✅ 余额连续性正确  
✅ 不混淆金额和余额  

---

## 🚀 下一步优化

### **1. 添加格式检测日志**

```javascript
console.log('🔍 检测到的表格结构:');
console.log('   列数:', columnCount);
console.log('   表头:', headers);
console.log('   格式类型:', formatType); // A/B/C
console.log('   金额列:', amountColumns);
console.log('   余额列:', balanceColumn);
```

### **2. 添加验证层**

```javascript
function validateTransaction(tx, prevTx) {
    // 验证余额连续性
    const expectedBalance = prevTx.balance + tx.amount * (tx.transactionSign === 'income' ? 1 : -1);
    const diff = Math.abs(expectedBalance - tx.balance);
    
    if (diff > 0.01) {
        console.warn('⚠️ 余额不连续，可能提取错误');
        console.warn('   预期:', expectedBalance);
        console.warn('   实际:', tx.balance);
    }
}
```

### **3. 提供格式反馈**

```javascript
// 在UI中显示识别的格式
显示: "检测到格式: 双列金额（支出/存入分离）"
或: "检测到格式: 单列金额（正负号表示）"
```

### **4. 支持手动校正**

```javascript
// 如果AI识别错误，允许用户指定格式
用户可以选择:
□ 双列格式（支出/存入分开）
□ 单列格式（正负号）
□ 只有余额变化
```

---

## 📝 总结

### **核心原则**

1. ✅ **智能识别**，不硬编码
2. ✅ **教AI理解**表格结构
3. ✅ **提供多种**格式示例
4. ✅ **添加验证**逻辑
5. ✅ **适配全球**所有银行

### **成功标准**

- ✅ 支持双列金额格式
- ✅ 支持单列+正负号格式
- ✅ 支持只有余额的格式
- ✅ 自动检测并适配
- ✅ 验证数据合理性

---

**设计状态**: ✅ 已完成  
**实施状态**: ✅ Prompt已更新  
**需要测试**: 多个不同银行的对账单

**关键优势**: 通过智能识别而非硬编码，支持全球任意银行！🌍

