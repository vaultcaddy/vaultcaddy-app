/**
 * VaultCaddy DeepSeek Vision ÂÆ¢Êà∂Á´Ø
 * 
 * ‰ΩúÁî®Ôºö
 * 1. ËôïÁêÜÂúñÁâáÊñáÊ™îÔºåÊèêÂèñÈóúÈçµ‰ø°ÊÅØ
 * 2. ‰ΩøÁî® DeepSeek Vision Ê®°ÂûãÔºåÊèê‰æõÈ´òÊ∫ñÁ¢∫Â∫¶ÁöÑÊï∏ÊìöÊèêÂèñ
 * 3. ÊîØÊåÅÁôºÁ•®„ÄÅÊî∂Êìö„ÄÅÈäÄË°åÂ∞çÂ∏≥ÂñÆÁ≠âÊñáÊ™îÈ°ûÂûã
 * 
 * @version 1.0.0
 * @updated 2025-10-26
 */
class DeepSeekVisionClient {
    constructor(workerUrl) {
        if (!workerUrl) {
            console.error('‚ùå Cloudflare Worker URL Êú™Êèê‰æõÔºÅ');
            throw new Error('Cloudflare Worker URL is required.');
        }
        this.workerUrl = workerUrl;
        
        // ‚úÖ ÂòóË©¶‰ΩøÁî®ÊîØÊåÅÂúñÁâáÁöÑÊ®°Âûã
        // ÂèØËÉΩÁöÑÊ®°ÂûãÂêçÁ®±Ôºö
        // - deepseek-vl2 (DeepSeek-VL2)
        // - deepseek-ocr (DeepSeek-OCR)
        // - janus-pro (Janus-Pro)
        // Â¶ÇÊûú‰∏çÊîØÊåÅÔºåÊúÉËá™ÂãïÈôçÁ¥ö
        this.modelsToTry = [
            'deepseek-vl2',      // DeepSeek-VL2 (ÊúÄÊé®Ëñ¶)
            'deepseek-ocr',      // DeepSeek-OCR
            'janus-pro-7b',      // Janus-Pro 7B
            'janus-pro-1b',      // Janus-Pro 1B
            'deepseek-chat'      // Á¥îÊñáÊú¨Ê®°ÂûãÔºàÈôçÁ¥öÈÅ∏È†ÖÔºâ
        ];
        
        this.model = this.modelsToTry[0]; // ÈªòË™ç‰ΩøÁî®Á¨¨‰∏ÄÂÄã
        this.maxRetries = 3;
        this.retryDelay = 2000; // 2 seconds
        
        console.log('ü§ñ DeepSeek Vision Client ÂàùÂßãÂåñ');
        console.log('   ‚úÖ Worker URL:', this.workerUrl);
        console.log('   ‚úÖ ÂòóË©¶Ê®°Âûã:', this.modelsToTry);
        console.log('   ‚úÖ ÈªòË™çÊ®°Âûã:', this.model);
    }
    
    /**
     * Â∞áÊñá‰ª∂ËΩâÊèõÁÇ∫ Base64 Ê†ºÂºè
     */
    async fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result.split(',')[1]); // Âè™Âèñ Base64 ÈÉ®ÂàÜ
            reader.onerror = error => reject(error);
            reader.readAsDataURL(file);
        });
    }
    
    /**
     * Ê†πÊìöÊñáÊ™îÈ°ûÂûãÁîüÊàêÂÑ™ÂåñÂæåÁöÑÊèêÁ§∫Ë©û
     */
    generatePrompt(documentType, file) {
        let prompt = '';
        
        // Áµ±‰∏ÄÁöÑ JSON Ëº∏Âá∫Ê†ºÂºèË¶ÅÊ±Ç
        const jsonFormatInstruction = `
        CRITICAL RULE: The output MUST be a pure JSON object. Do NOT include any other text, explanations, or markdown outside the JSON.
        The JSON structure should be as follows:
        {
            "document_type": "invoice | receipt | bank_statement | general",
            "confidence_score": 0-100, // Overall confidence of extraction
            "extracted_data": { ... } // Document-specific data
        }
        `;
        
        switch (documentType) {
            case 'invoice':
                prompt = `
                You are an expert accounting AI. Analyze the provided invoice image.
                Extract ALL relevant information for bookkeeping and reconciliation.
                
                CRITICAL RULES:
                1. Extract ALL line items with their code, description, quantity, unit, unit_price, and amount. If any field is missing, use an empty string or 0.
                2. Calculate subtotal, discount, tax, and total. If tax is not explicitly stated, assume 0.
                3. Identify currency (e.g., HKD, USD). Default to HKD if not found.
                4. Extract supplier and customer details including name, address, phone, and email.
                5. Extract payment method, payment status, due date, and any specific payment IDs (e.g., FPS ID, PayMe Number).
                6. If a field is not present, return an empty string or 0, do NOT make up data.
                7. Ensure all numerical values are parsed as numbers (float or integer).
                8. Dates should be in YYYY-MM-DD format.
                
                Extract the following fields:
                - invoice_number (string)
                - date (YYYY-MM-DD)
                - due_date (YYYY-MM-DD)
                - supplier: { name (string), name_en (string, if available), address (string), phone (string), email (string) }
                - customer: { name (string), address (string), contact (string), phone (string) }
                - items: [ { code (string), description (string), quantity (number), unit (string), unit_price (number), amount (number) } ]
                - subtotal (number)
                - discount (number)
                - tax (number)
                - total (number)
                - currency (string, e.g., HKD)
                - payment_method (string)
                - payment_status (string)
                - payment_info: { fps_id (string), payme_number (string) }
                - notes (string)
                
                Example for line items:
                "items": [
                    { "code": "ITEM001", "description": "Product A", "quantity": 2, "unit": "pcs", "unit_price": 100.00, "amount": 200.00 },
                    { "code": "ITEM002", "description": "Service B", "quantity": 1, "unit": "hr", "unit_price": 500.00, "amount": 500.00 }
                ]
                `;
                break;
            
            case 'receipt':
                prompt = `
                You are an expert accounting AI. Analyze the provided receipt image.
                Extract ALL relevant information for bookkeeping and reconciliation.
                
                CRITICAL RULES:
                1. Extract merchant details including name, address, phone, and email.
                2. Extract transaction date and time.
                3. Extract ALL line items with their description, quantity, unit_price, and amount.
                4. Calculate subtotal, tax, and total. If tax is not explicitly stated, assume 0.
                5. Identify currency (e.g., HKD, USD). Default to HKD if not found.
                6. Extract payment method.
                7. If a field is not present, return an empty string or 0, do NOT make up data.
                8. Ensure all numerical values are parsed as numbers (float or integer).
                9. Dates should be in YYYY-MM-DD format, time in HH:MM.
                
                Extract the following fields:
                - transaction_id (string)
                - date (YYYY-MM-DD)
                - time (HH:MM)
                - merchant: { name (string), address (string), phone (string), email (string) }
                - items: [ { description (string), quantity (number), unit_price (number), amount (number) } ]
                - subtotal (number)
                - tax (number)
                - total (number)
                - currency (string, e.g., HKD)
                - payment_method (string)
                - notes (string)
                `;
                break;
            
            case 'bank_statement':
                prompt = `
                You are an expert accounting AI. Analyze the provided bank statement image.
                Extract ALL relevant information for bookkeeping and reconciliation.
                
                CRITICAL RULES:
                1. Extract bank name, account number, and account holder name.
                2. Extract the statement period (start and end dates).
                3. Extract opening and closing balances.
                4. Extract ALL transactions with their date, description, type (credit/debit), amount, and running balance.
                5. If a field is not present, return an empty string or 0, do NOT make up data.
                6. Ensure all numerical values are parsed as numbers (float or integer).
                7. Dates should be in YYYY-MM-DD format.
                
                Extract the following fields:
                - bank: { name (string), address (string) }
                - account_number (string)
                - account_holder: { name (string) }
                - statement_period: { from (YYYY-MM-DD), to (YYYY-MM-DD) }
                - opening_balance (number)
                - closing_balance (number)
                - currency (string, e.g., HKD)
                - transactions: [ { date (YYYY-MM-DD), description (string), type (string, "credit" or "debit"), amount (number), balance (number) } ]
                `;
                break;
            
            default: // general document
                prompt = `
                You are an expert document analysis AI. Analyze the provided document image.
                Extract key entities and a summary of the document's content.
                
                CRITICAL RULES:
                1. Identify the main purpose or type of the document.
                2. Extract any dates, names, addresses, and monetary values.
                3. Provide a concise summary of the document's content.
                4. If a field is not present, return an empty string or 0, do NOT make up data.
                
                Extract the following fields:
                - document_type_identified (string, e.g., "General Document", "Letter", "Contract")
                - main_entities: [ { type (string, e.g., "Person", "Organization", "Date", "Amount"), value (string) } ]
                - summary (string)
                `;
                break;
        }
        
        return {
            system: `You are a highly accurate AI assistant specialized in extracting structured data from financial documents.
            Your task is to meticulously analyze the provided image and extract all requested information.
            ${jsonFormatInstruction}`,
            user: prompt
        };
    }
    
    /**
     * ËôïÁêÜÊñáÊ™îÔºàÊô∫ËÉΩÊ®°ÂûãÈÅ∏ÊìáÔºâ
     */
    async processDocument(file, documentType = 'general') {
        console.log(`üöÄ DeepSeek Vision Client ËôïÁêÜÊñáÊ™î: ${file.name} (${documentType})`);
        
        let base64Data;
        try {
            base64Data = await this.fileToBase64(file);
        } catch (error) {
            console.error('‚ùå Êñá‰ª∂ËΩâ Base64 Â§±Êïó:', error);
            throw new Error('Failed to convert file to Base64 for DeepSeek Vision.');
        }
        
        const { system, user } = this.generatePrompt(documentType, file);
        
        // üîÑ Êô∫ËÉΩÊ®°ÂûãÈÅ∏ÊìáÔºöÊåâÈ†ÜÂ∫èÂòóË©¶ÊØèÂÄãÊ®°Âûã
        for (let modelIndex = 0; modelIndex < this.modelsToTry.length; modelIndex++) {
            const currentModel = this.modelsToTry[modelIndex];
            console.log(`\nü§ñ ÂòóË©¶Ê®°Âûã ${modelIndex + 1}/${this.modelsToTry.length}: ${currentModel}`);
            
            const requestBody = {
                model: currentModel,
                messages: [
                    {
                        role: "system",
                        content: system
                    },
                    {
                        role: "user",
                        content: [
                            {
                                type: "text",
                                text: user
                            },
                            {
                                type: "image_url",
                                image_url: {
                                    url: `data:${file.type};base64,${base64Data}`
                                }
                            }
                        ]
                    }
                ],
                max_tokens: 4000,
                temperature: 0.1
            };
            
            try {
                console.log(`   üì§ ÁôºÈÄÅË´ãÊ±ÇÂà∞ DeepSeek API...`);
                const response = await fetch(this.workerUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    console.warn(`   ‚ö†Ô∏è Ê®°Âûã ${currentModel} Â§±Êïó (${response.status}):`, errorData.error?.message || errorData.message);
                    
                    // Â¶ÇÊûúÊòØ 400 ÈåØË™§ÔºàÊ®°Âûã‰∏çÊîØÊåÅÔºâÔºåÂòóË©¶‰∏ã‰∏ÄÂÄãÊ®°Âûã
                    if (response.status === 400) {
                        console.log(`   ‚è≠Ô∏è  Ë∑≥ÈÅéÊ®°Âûã ${currentModel}ÔºåÂòóË©¶‰∏ã‰∏ÄÂÄã...`);
                        continue;
                    }
                    
                    throw new Error(`DeepSeek API error: ${response.status} - ${errorData.error?.message || response.statusText}`);
                }
                
                const data = await response.json();
                
                if (!data.choices || data.choices.length === 0 || !data.choices[0].message) {
                    throw new Error('DeepSeek API ËøîÂõûÁÑ°ÊïàÈüøÊáâ');
                }
                
                const content = data.choices[0].message.content;
                console.log(`   ‚úÖ Ê®°Âûã ${currentModel} ÊàêÂäüËøîÂõûÈüøÊáâ`);
                console.log(`   üìÑ ÈüøÊáâÂÖßÂÆπ:`, content.substring(0, 200) + '...');
                
                let parsedData;
                try {
                    parsedData = JSON.parse(content);
                } catch (jsonError) {
                    console.error('   ‚ùå JSON Ëß£ÊûêÂ§±Êïó:', jsonError);
                    // ÂòóË©¶Ê∏ÖÁêÜÈüøÊáâÔºàÁßªÈô§ markdown ‰ª£Á¢ºÂ°äÔºâ
                    const cleaned = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    try {
                        parsedData = JSON.parse(cleaned);
                        console.log('   ‚úÖ Ê∏ÖÁêÜÂæå JSON Ëß£ÊûêÊàêÂäü');
                    } catch (cleanError) {
                        throw new Error('Failed to parse DeepSeek response as JSON.');
                    }
                }
                
                // Ê™¢Êü•‰∏¶Á¢∫‰øùËøîÂõûÁöÑ JSON ÁµêÊßãÁ¨¶ÂêàÈ†êÊúü
                if (!parsedData.document_type || !parsedData.extracted_data) {
                    console.warn('   ‚ö†Ô∏è JSON ÁµêÊßã‰∏çÂÆåÊï¥ÔºåÂòóË©¶‰∏ã‰∏ÄÂÄãÊ®°Âûã...');
                    continue;
                }
                
                // üéâ ÊàêÂäüÔºÅË®òÈåÑ‰ΩøÁî®ÁöÑÊ®°Âûã
                this.model = currentModel; // Êõ¥Êñ∞ÁÇ∫ÊàêÂäüÁöÑÊ®°Âûã
                console.log(`\nüéâ ÊàêÂäü‰ΩøÁî®Ê®°Âûã: ${currentModel}`);
                
                return {
                    success: true,
                    documentType: parsedData.document_type,
                    confidence: parsedData.confidence_score || 0,
                    extractedData: parsedData.extracted_data,
                    model: currentModel, // ËøîÂõû‰ΩøÁî®ÁöÑÊ®°ÂûãÂêçÁ®±
                    rawResponse: data
                };
                
            } catch (error) {
                console.error(`   ‚ùå Ê®°Âûã ${currentModel} ËôïÁêÜÂ§±Êïó:`, error.message);
                
                // Â¶ÇÊûú‰∏çÊòØÊúÄÂæå‰∏ÄÂÄãÊ®°ÂûãÔºåÁπºÁ∫åÂòóË©¶‰∏ã‰∏ÄÂÄã
                if (modelIndex < this.modelsToTry.length - 1) {
                    console.log(`   ‚è≠Ô∏è  ÂòóË©¶‰∏ã‰∏ÄÂÄãÊ®°Âûã...`);
                    continue;
                } else {
                    // ÊâÄÊúâÊ®°ÂûãÈÉΩÂ§±Êïó‰∫Ü
                    throw new Error(`ÊâÄÊúâ DeepSeek Ê®°ÂûãÈÉΩÂ§±Êïó‰∫Ü„ÄÇÊúÄÂæåÈåØË™§: ${error.message}`);
                }
            }
        }
        
        // Â¶ÇÊûúÊâÄÊúâÊ®°ÂûãÈÉΩÂ§±ÊïóÔºà‰∏çÊáâË©≤Âà∞ÈÅîÈÄôË£°Ôºâ
        throw new Error('ÁÑ°Ê≥ï‰ΩøÁî®‰ªª‰Ωï DeepSeek Ê®°ÂûãËôïÁêÜÊñáÊ™î');
    }
}

// ÂÖ®Â±ÄÊö¥Èú≤
if (typeof window !== 'undefined') {
    window.DeepSeekVisionClient = DeepSeekVisionClient;
    console.log('‚úÖ DeepSeek Vision Client Ê®°Â°äÂ∑≤ËºâÂÖ•');
}

// Node.js Áí∞Â¢ÉÂ∞éÂá∫ (Â¶ÇÊûúÈúÄË¶Å)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = DeepSeekVisionClient;
}

