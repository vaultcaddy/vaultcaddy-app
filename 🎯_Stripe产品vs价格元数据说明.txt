# 🎯 Stripe 产品 vs 价格元数据说明

## 📋 **问题总结**

用户问题：
1. 产品（Product）`prod_TZsmHUx2KVga8H` 包含两个价格（Price）
2. 价格 `price_1Scj13JmiQ31C0GT4TJsWzFg` 已经有元数据
3. **问题**：产品也需要加元数据吗？价格上的元数据有什么意义？

---

## ✅ **答案：两者都需要元数据，但用途不同！**

### **1. 产品（Product）的元数据**

**用途**：
- 用于描述整个产品的**业务属性**
- 我们的代码从**产品元数据**获取 `monthly_credits` 和 `plan_type`

**我们需要的产品元数据**：
```
monthly_credits: 100
plan_type: monthly
```

**为什么需要在产品上设置？**

因为我们的代码是这样写的：

```javascript
// firebase-functions/index.js 第 326 行
const product = await stripeClient.products.retrieve(subscription.items.data[0].price.product);

console.log(`📦 訂閱產品信息:`, {
    productId: product.id,
    name: product.name,
    metadata: product.metadata  // ← 从产品获取 metadata
});

// 第 335-336 行
let planType = product.metadata.plan_type || 'monthly';
let monthlyCredits = parseInt(product.metadata.monthly_credits || product.metadata.credits || 0);
```

**如果产品没有元数据会怎样？**

从日志看到：
```
📦 訂閱產品信息: {
  productId: 'prod_TZsmHUx2KVga8H',
  name: 'VaultCaddy 月費 test',
  metadata: {}  ← 空的！
}
📊 訂閱詳情: { planType: 'monthly', monthlyCredits: 0, status: 'active' }
⚠️ 產品 VaultCaddy 月費 test 沒有配置 credits，跳過添加
```

**结果**：Credits 不会被添加！

---

### **2. 价格（Price）的元数据**

**用途**：
- 用于描述**具体定价方案**的属性
- 可以用于更细粒度的控制（例如：不同价格对应不同的 Credits）

**价格元数据的好处**：
- 如果你有多个价格（例如：月费 $58、年费 $552），可以为每个价格设置不同的 Credits
- 更灵活的配置

**当前情况**：
- 你的价格 `price_1Scj13JmiQ31C0GT4TJsWzFg` 已经有元数据
- 但是我们的代码**没有读取价格元数据**，只读取产品元数据

---

## 🔧 **解决方案（两个选项）**

### **选项 1：在产品上添加元数据（推荐）** ⭐

**优点**：
- 不需要修改代码
- 所有价格共享同一个元数据

**步骤**：

1. 在 Stripe Dashboard 中打开产品页面：
   https://dashboard.stripe.com/test/products/prod_TZsmHUx2KVga8H

2. 找到 **"元数据"** 部分（可能需要向下滚动）

3. 点击 **"编辑"** 或 **"添加元数据"**

4. 添加：
   - **键**: `monthly_credits`
   - **值**: `100`
   
   - **键**: `plan_type`
   - **值**: `monthly`

5. 保存

---

### **选项 2：修改代码，从价格元数据获取（更灵活）**

**优点**：
- 每个价格可以有不同的 Credits
- 更灵活

**缺点**：
- 需要修改代码
- 需要重新部署

**代码修改**：

```javascript
// 修改 handleSubscriptionChange 函数
const priceId = subscription.items.data[0].price.id;
const price = await stripeClient.prices.retrieve(priceId);
const product = await stripeClient.products.retrieve(price.product);

// 优先使用价格元数据，如果没有则使用产品元数据
let planType = price.metadata.plan_type || product.metadata.plan_type || 'monthly';
let monthlyCredits = parseInt(
    price.metadata.monthly_credits || 
    price.metadata.credits || 
    product.metadata.monthly_credits || 
    product.metadata.credits || 
    0
);
```

---

## 📊 **当前情况总结**

| 位置 | 当前状态 | 我们的代码是否读取 | 需要添加吗 |
|------|---------|------------------|-----------|
| **产品（Product）** `prod_TZsmHUx2KVga8H` | ❌ 没有元数据 | ✅ **是** | ✅ **是** |
| **价格（Price）** `price_1Scj13JmiQ31C0GT4TJsWzFg` | ✅ 有元数据 | ❌ 否 | ⚠️ 可选 |

---

## 📞 **推荐行动**

**立即执行选项 1**：

1. **在产品上添加元数据**
   - `monthly_credits: 100`
   - `plan_type: monthly`

2. **重新测试支付**
   - 点击 "🧪 測試 Get Started"
   - 完成支付
   - 确认 Credits 从 20 增加到 120

**完成后告诉我结果！** 🙏

---

## 🎯 **为什么会这样设计？**

**Stripe 的设计逻辑**：
- **产品（Product）**：代表一个商品（例如：VaultCaddy 月费）
- **价格（Price）**：代表该商品的具体定价方案（例如：$58/月、$552/年）

**一个产品可以有多个价格**：
- 例如：同一个产品 "VaultCaddy 月费"
- 可以有价格 1：$58/月（固定费用）
- 可以有价格 2：$0.5/页（用量计费）

**元数据的最佳实践**：
- **产品元数据**：存储产品级别的属性（例如：这个产品对应多少 Credits）
- **价格元数据**：存储价格级别的属性（例如：这个具体的定价方案的特殊规则）

**我们当前的代码**：
- 只读取产品元数据
- 所以必须在产品上添加元数据

**如果未来需要更灵活的配置**：
- 可以修改代码，同时读取产品和价格元数据
- 优先使用价格元数据，如果没有则使用产品元数据

