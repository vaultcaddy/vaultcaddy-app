# 🎯 AI 的角色定位：从「会计师」到「搬运工」

**核心理念转变日期**: 2026年2月1日  
**问题来源**: 用户深刻洞察 - "我们的工作只是搬运数据到正确位置"  
**状态**: ✅ 已实施并可测试

---

## 💡 用户的核心洞察

### 问题背景

用户发现虽然修复了"余额计算"的问题，但还有一个更根本的问题：

> **"所有不同的銀行單都要適用"**

### 用户的两大原则

**第 1 原则**：
> "不改任何數值"

**第 2 原则**：
> "我們的工作只是搬運數據到正確位置，及檢查金額是支出／存入，我們不用計算是否正確，我們只需確保提取的數據和用戶上載的數據是一樣就可以了。"

### 核心问题

> **"你認為有什麼方法檢查金額是支出／存入？"**

---

## 🔄 理念转变

### ❌ 旧理念：AI 是会计师

**角色定位**：
- 验证数据的正确性
- 计算余额是否正确
- 审计交易记录
- "帮助"用户"修正"错误

**问题**：
1. 银行单格式千差万别
2. AI 会"聪明地"做出错误判断
3. 试图"修正"银行的数据
4. 不同银行单可能失败

### ✅ 新理念：AI 是搬运工

**角色定位**：
- 从 PDF 搬运数据到 JSON
- 不验证、不计算、不审计
- 确保"提取的 = 上传的"
- 银行永远是对的

**优势**：
1. ✅ 适用于所有银行单格式
2. ✅ 不会"聪明地"出错
3. ✅ 不会修改银行数据
4. ✅ 简单、可靠、通用

---

## 🏦 所有银行单的通用性

### 挑战：银行单格式千差万别

**不同银行的格式**：

| 银行 | 格式特点 |
|-----|---------|
| **ICBC 香港** | 有明确的"支出"和"存入"列 |
| **HSBC** | 只有"金额"列 + 余额列 |
| **中国银行** | 金额带 +/- 符号 |
| **恒生银行** | 有 debit/credit 列 |
| **其他银行** | 各种不同格式 |

**问题**：
- 如果只针对一种格式优化 → 其他格式失败
- 如果依赖特定列名 → 不同银行单失败
- 如果依赖文字标签 → 标签冲突时失败

### 解决方案：优先级策略

**核心思想**：
- 不依赖任何特定格式
- 建立优先级fallback机制
- 从最可靠到最不可靠

---

## 📊 transactionSign 判断的优先级策略

### PRIORITY 1 - Direct Extraction（最可靠）

**适用场景**：银行单有明确的标注

**情况 1：有 debit/credit 列**

```
日期        描述              支出        存入        餘額
2022/02/04  八達通            8,122.80              51,295.09
2022/02/05  存款现金                    25,000.00  76,295.09
```

**提取方法**：
```json
{
  "date": "2022-02-04",
  "description": "八達通",
  "debit": 8122.80,          // ✅ 从"支出"列直接提取
  "credit": 0,
  "transactionSign": "expense"  // ✅ 有 debit → expense
}
{
  "date": "2022-02-05",
  "description": "存款现金",
  "debit": 0,
  "credit": 25000.00,        // ✅ 从"存入"列直接提取
  "transactionSign": "income"   // ✅ 有 credit → income
}
```

**情况 2：金额有 +/- 符号**

```
日期        描述              金額          餘額
2022/02/04  八達通            -8,122.80    51,295.09
2022/02/05  存款现金          +25,000.00   76,295.09
```

**提取方法**：
```json
{
  "date": "2022-02-04",
  "description": "八達通",
  "debit": 8122.80,          // ✅ 负号 → debit
  "credit": 0,
  "transactionSign": "expense"  // ✅ 负号 → expense
}
{
  "date": "2022-02-05",
  "description": "存款现金",
  "debit": 0,
  "credit": 25000.00,        // ✅ 正号 → credit
  "transactionSign": "income"   // ✅ 正号 → income
}
```

### PRIORITY 2 - Balance Comparison（可靠的fallback）

**适用场景**：银行单只有"金额"列 + "余额"列

```
日期        描述              金額        餘額
2022/02/04  八達通            8,122.80   51,295.09
2022/02/05  存款现金          25,000.00  76,295.09
```

**提取方法**（通过余额推断）：

**步骤**：
1. 提取前一笔余额：51,295.09
2. 提取当前余额：76,295.09
3. 比较：76,295.09 > 51,295.09
4. 推断：余额增加 = 存入

```json
{
  "date": "2022-02-05",
  "description": "存款现金",
  "amount": 25000.00,        // ✅ 从"金額"列提取
  "balance": 76295.09,       // ✅ 从"餘額"列提取
  "debit": 0,
  "credit": 25000.00,
  "transactionSign": "income"   // ✅ 余额增加 → income
}
```

**为什么这不是"计算"？**

这是**基于事实的推断**，不是计算：

| 操作 | 类型 | 说明 |
|-----|------|------|
| `balance = prev + credit - debit` | ❌ 计算 | 使用公式算出余额 |
| `if balance > prev_balance then income` | ✅ 推断 | 基于客观事实推断 |

**客观事实**：
- 余额增加 = 有钱进来 = 存入（这是事实）
- 余额减少 = 有钱出去 = 支出（这是事实）

### PRIORITY 3 - Ignore Text Labels（最不可靠）

**为什么文字标签不可靠？**

**情况：文字标签冲突**

```
日期        描述              類型    金額        餘額
2022/02/04  退款              支出    100.00     200.00
```

**分析**：
- 文字标签说："支出"
- 前一笔余额：100.00
- 当前余额：200.00
- 余额增加了！

**正确判断**：
```json
{
  "transactionSign": "income"  // ✅ 余额增加 → income（忽略文字"支出"）
}
```

**为什么会有冲突？**

1. **OCR 识别错误**：可能错误识别文字
2. **银行标签不统一**：不同银行对"退款"的标注不同
3. **复杂交易**：转账、退款、调整等可能标注混乱
4. **人工录入错误**：银行也可能出错（虽然很少）

**优先级原则**：
```
debit/credit 列 > 余额比较 > 文字标签
```

---

## 🌍 适用性验证

### 测试场景 1：ICBC 香港（有明确列）

**格式**：
```
日期        描述              支出        存入        餘額
2022/02/04  八達通            8,122.80              51,295.09
```

**提取策略**：
- ✅ 使用 PRIORITY 1（直接提取）
- ✅ 从"支出"列提取 → debit: 8122.80
- ✅ transactionSign: "expense"

### 测试场景 2：HSBC（只有金额列）

**格式**：
```
Date        Description      Amount      Balance
2022/02/04  OCTOPUS          8,122.80    51,295.09
```

**提取策略**：
- ✅ 使用 PRIORITY 2（余额比较）
- ✅ 提取余额：51,295.09
- ✅ 比较前一笔余额
- ✅ 推断：transactionSign

### 测试场景 3：中国银行（+/- 符号）

**格式**：
```
日期        描述              金額          餘額
2022/02/04  八達通            -8,122.80    51,295.09
```

**提取策略**：
- ✅ 使用 PRIORITY 1（直接提取）
- ✅ 识别负号 → debit: 8122.80
- ✅ transactionSign: "expense"

### 测试场景 4：其他银行（文字标签冲突）

**格式**：
```
日期        描述        類型    金額        餘額
2022/02/04  退款        支出    100.00     200.00
```

**提取策略**：
- ⚠️ PRIORITY 1 不可用（没有明确列）
- ✅ 使用 PRIORITY 2（余额比较）
- ✅ 余额增加 → transactionSign: "income"
- ✅ 忽略文字"支出"（PRIORITY 3）

---

## 📋 搬运工的工作清单

### ✅ 搬运工做什么？

1. **提取日期** - 从 PDF 复制到 JSON
2. **提取描述** - 从 PDF 复制到 JSON
3. **提取金额** - 从 PDF 复制到 JSON
4. **提取余额** - 从 PDF 复制到 JSON
5. **推断 transactionSign** - 使用优先级策略

### ❌ 搬运工不做什么？

1. **不计算余额** - balance = prev + credit - debit ❌
2. **不验证正确性** - "这个余额看起来不对" ❌
3. **不修正数据** - "让我改成正确的值" ❌
4. **不审计交易** - "这笔交易有问题" ❌
5. **不质疑银行** - "银行可能算错了" ❌

### 🎯 搬运工的目标

**唯一目标**：
```
"提取的数据" = "用户上传的数据"
```

**验证方法**：
1. 打开 PDF，看到余额是 30,718.39
2. 打开 JSON，看到 `"balance": 30718.39`
3. ✅ 完全一致 → 搬运成功

---

## 🧪 测试用例

### 测试 1：基本提取（有明确列）

**输入（PDF）**：
```
日期        描述              支出        存入        餘額
2022/02/01  承上結餘                              30,718.39
2022/02/04  八達通            8,122.80              51,295.09
2022/02/05  存款现金                    25,000.00  48,459.59
```

**预期输出（JSON）**：
```json
{
  "transactions": [
    {
      "date": "2022-02-01",
      "description": "承上結餘",
      "balance": 30718.39,
      "transactionSign": "income"
    },
    {
      "date": "2022-02-04",
      "description": "八達通",
      "debit": 8122.80,
      "balance": 51295.09,
      "transactionSign": "expense"
    },
    {
      "date": "2022-02-05",
      "description": "存款现金",
      "credit": 25000.00,
      "balance": 48459.59,
      "transactionSign": "income"
    }
  ]
}
```

**验证**：
- ✅ 所有数字与 PDF 完全一致
- ✅ transactionSign 基于 debit/credit 列判断
- ✅ 没有计算，只有提取

### 测试 2：余额比较（没有明确列）

**输入（PDF）**：
```
Date        Description      Amount      Balance
2022/02/01  Opening          0.00        100.00
2022/02/04  OCTOPUS          50.00       80.00
2022/02/05  DEPOSIT          30.00       110.00
```

**预期输出（JSON）**：
```json
{
  "transactions": [
    {
      "date": "2022-02-01",
      "description": "Opening",
      "amount": 0.00,
      "balance": 100.00,
      "transactionSign": "income"
    },
    {
      "date": "2022-02-04",
      "description": "OCTOPUS",
      "amount": 50.00,
      "balance": 80.00,
      "debit": 50.00,
      "transactionSign": "expense"  // ✅ 100 → 80（减少）→ expense
    },
    {
      "date": "2022-02-05",
      "description": "DEPOSIT",
      "amount": 30.00,
      "balance": 110.00,
      "credit": 30.00,
      "transactionSign": "income"   // ✅ 80 → 110（增加）→ income
    }
  ]
}
```

**验证**：
- ✅ 所有余额与 PDF 完全一致
- ✅ transactionSign 基于余额比较推断
- ✅ 没有使用公式计算

### 测试 3：文字标签冲突

**输入（PDF）**：
```
日期        描述        類型    金額        餘額
2022/02/01  前一笔                      100.00
2022/02/04  退款        支出    50.00      150.00
```

**预期输出（JSON）**：
```json
{
  "transactions": [
    {
      "date": "2022-02-01",
      "description": "前一笔",
      "balance": 100.00
    },
    {
      "date": "2022-02-04",
      "description": "退款",
      "amount": 50.00,
      "balance": 150.00,
      "credit": 50.00,
      "transactionSign": "income"  // ✅ 忽略"支出"文字，余额增加 → income
    }
  ]
}
```

**验证**：
- ✅ 余额与 PDF 完全一致
- ✅ 忽略了冲突的文字标签
- ✅ 使用余额比较推断（可靠）

---

## 💡 为什么这个方法适用于所有银行单？

### 1. 不依赖特定格式

**传统方法的问题**：
```javascript
// ❌ 假设所有银行单都有"支出"列
if (row.支出 > 0) {
    transactionSign = "expense"
}
```

**问题**：
- 有些银行单用"Debit"
- 有些银行单用"支出"
- 有些银行单只有"金額"

**新方法**：
```javascript
// ✅ 优先级 fallback
if (hasDebitCreditColumns) {
    // 使用 PRIORITY 1
} else if (hasBalanceColumn) {
    // 使用 PRIORITY 2（余额比较）
} else {
    // 使用 PRIORITY 3（最后选择）
}
```

### 2. 基于事实，不是假设

**传统方法**：
- 假设：文字标签是对的
- 假设：列名是固定的
- 假设：格式是统一的

**新方法**：
- 事实：余额增加 = 存入（这对所有银行都成立）
- 事实：余额减少 = 支出（这对所有银行都成立）
- 事实：银行打印的数字是对的（这对所有银行都成立）

### 3. 从最可靠到最不可靠

**可靠性排序**：
1. 🟢 **最可靠**：明确的 debit/credit 列
2. 🟡 **可靠**：余额比较（基于客观事实）
3. 🔴 **最不可靠**：文字标签（可能冲突）

**好处**：
- 优先使用最可靠的方法
- 如果不可用，fallback 到次可靠的方法
- 确保所有情况都有解决方案

---

## 🎓 经验总结

### 搬运工哲学的优势

**1. 简单**
- 不需要复杂的验证逻辑
- 不需要审计规则
- 只需要：提取 + 推断

**2. 可靠**
- 不会"聪明地"出错
- 不会"帮倒忙"
- 银行永远是对的

**3. 通用**
- 适用于所有银行单格式
- 不受特定格式限制
- 优先级 fallback 机制

**4. 可维护**
- 逻辑清晰
- 容易理解
- 容易调试

### 与会计师方法的对比

| 维度 | 会计师方法 | 搬运工方法 |
|-----|-----------|-----------|
| **角色** | 验证、审计 | 提取、搬运 |
| **目标** | 数据正确性 | 数据一致性 |
| **方法** | 计算、验证 | 提取、推断 |
| **适用性** | 特定格式 | 所有格式 |
| **可靠性** | 可能出错 | 简单可靠 |
| **复杂度** | 复杂 | 简单 |

### 关键洞察

**用户的智慧**：
> "我們的工作只是搬運數據到正確位置"

**这句话的深刻含义**：
1. **角色定位**：搬运工，不是会计师
2. **工作目标**：数据到正确位置，不是数据正确性
3. **工作方法**：搬运，不是验证
4. **工作原则**：提取的 = 上传的

**这是整个系统设计的哲学基础**。

---

## 🚀 下一步测试

### 测试计划

**目标**：验证新方法适用于所有银行单

**测试银行单**：
1. ✅ ICBC 香港（有明确列）
2. ✅ HSBC（只有金额列）
3. ✅ 中国银行（+/- 符号）
4. ✅ 恒生银行（debit/credit 列）
5. ✅ 其他格式（测试 fallback）

**验证标准**：
1. 所有余额与 PDF 完全一致
2. transactionSign 判断准确
3. 没有计算痕迹
4. 适用于所有格式

### 预期结果

**修复前**：
```
只针对 ICBC 优化 → 其他银行单可能失败
依赖特定列名 → 格式不同时失败
```

**修复后**：
```
✅ ICBC: 使用 PRIORITY 1（debit/credit 列）
✅ HSBC: 使用 PRIORITY 2（余额比较）
✅ 中国银行: 使用 PRIORITY 1（+/- 符号）
✅ 所有银行: 自动选择最合适的方法
```

---

## 📖 参考文档

相关文档：
- `BALANCE_CALCULATION_FIX.md` - 余额计算问题的修复
- `PROMPT_FIX_DATE_AMOUNT_ACCURACY.md` - 日期和金额准确性修复
- `TRANSACTION_SIGN_LOGIC_EXPLANATION.md` - transactionSign 判断逻辑

---

**生成时间**：2026年2月1日  
**核心理念**：AI 是搬运工，不是会计师  
**核心目标**：提取的 = 上传的  
**适用性**：所有银行单格式 ✅

